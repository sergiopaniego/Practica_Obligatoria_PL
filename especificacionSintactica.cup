import java_cup.runtime.*;
parser code{:
	public void syntax_error(Symbol s){
    System.out.println("compiler has detected a syntax error at line " + s.left 
        + " column " + s.right);
	}
:}


/* Terminals (tokens returned by the scanner). */
terminal  left_parenthesis, right_parenthesis, left_bracket, right_bracket, 
	addition_sign, substraction_sign, multiplication_sign, slash, percent, constint, constfloat, constlit, void_token, int_token,
 	float_token,comma, semicolon, equal, until_token, while_token, else_token, if_token, then_token, for_token, return_token,
	more_than, less_than, less_than_equal_to, more_than_equal_to, double_equal, do_token,  and, or, not, struct, dot,
	left_squarebracket, right_squarebracket;
terminal  String ident;

non terminal PROGRAM, PART, RESTPART, LISTPARAM, BLQ, SENTLIST, SENT, LID, EXP, FACTOR, LEXP, LFIELD,
	 LCOND, COND, LDIM, S;
non terminal String ID, OPL, OPR, TYPE, OP;



precedence left addition_sign;
precedence left substraction_sign;
precedence left multiplication_sign;
precedence left slash;
precedence left percent;
precedence left and;
precedence left or;
precedence left equal;

S ::= {:System.out.println("<!DOCTYPE html>");System.out.println("<html>");System.out.println("<head>");System.out.println("<title></title>");System.out.println("</head>");System.out.println("<body>");:}PROGRAM {:System.out.println("</body>");System.out.println("</HTML>");:};
PROGRAM ::=  PART PROGRAM {::}|  PART;
PART ::= TYPE:type {:switch(type){
case "v": System.out.print("void "); break;
case "i": System.out.print("int "); break;
case "f": System.out.print("float "); break;
};:} RESTPART  |  struct ident:ident1 left_bracket {:System.out.println("struct "+ident1+" {");:} LFIELD right_bracket semicolon {:System.out.println("};");:};
RESTPART ::= ident:ident1 left_parenthesis {:System.out.print(ident1+" (");:} LISTPARAM right_parenthesis {:System.out.print(")");:} BLQ;
BLQ ::= left_bracket {:System.out.println("{");:} SENTLIST right_bracket {:System.out.println("}");:};
LISTPARAM ::= LISTPARAM comma {:System.out.print(", ");:}TYPE:type ident:ident1 {:switch(type){
case "v": System.out.print("void "); break;
case "i": System.out.print("int "); break;
case "f": System.out.print("float "); break;
};System.out.print(ident1);:} | TYPE:type ident:ident1 {:switch(type){
case "v": System.out.print("void "); break;
case "i": System.out.print("int "); break;
case "f": System.out.print("float "); break;
}; System.out.print(ident1);:};
TYPE ::= void_token {:RESULT = "v";:}| int_token {:RESULT = "i";:} | float_token{:RESULT = "f";:};
SENTLIST ::= SENTLIST SENT | SENT ;
SENT ::=  ID:ident1 equal {:System.out.print(ident1+" = ");:} EXP semicolon {:System.out.println(";");:};
SENT::= TYPE:type {:switch(type){
case "v": System.out.print("void "); break;
case "i": System.out.print("int "); break;
case "f": System.out.print("float "); break;
};:} LID:ident1 semicolon {:System.out.println(ident1+";");:} | ident:ident1 equal  {:System.out.print(ident1+" = ");:} 
EXP semicolon {:System.out.println(";");:} 
| ident:ident1 left_parenthesis {:System.out.print(ident1+"( ");:} LEXP right_parenthesis semicolon {:System.out.println(");");:} 
| return_token {:System.out.print("return");:} EXP semicolon {:System.out.println(";");:};
SENT ::= if_token left_parenthesis {:System.out.print("if (");:}LCOND right_parenthesis then_token {:System.out.print(") then");:} BLQ else_token {:System.out.print("else");:} BLQ
	| for_token left_parenthesis ident:ident1 equal {:System.out.print("for("+ident1+ " = ");:} EXP semicolon {:System.out.println(";");:} 
        LCOND semicolon ident:ident2 equal {:System.out.print("; "+ident2+" = ");:} EXP right_parenthesis {:System.out.print(")");:}BLQ
	| while_token left_parenthesis {:System.out.print("while (");:} LCOND right_parenthesis {:System.out.print(")");:} BLQ
	| do_token {:System.out.print("do ");:} BLQ until_token left_parenthesis {:System.out.print("until (");:} LCOND right_parenthesis {:System.out.print(")");:}
	| BLQ;
LCOND ::= LCOND OPL:opl LCOND {:switch(opl){
case "a": System.out.println("and"); break;
case "o": System.out.println("or"); break;
};:}| COND | not COND;
OPL ::= or {:RESULT = "o";:} | and {:RESULT = "a";:} ;
COND ::= EXP OPR:opr   EXP {:switch(opr){
case "lt": System.out.println("<"); break;
case "mt": System.out.println(">"); break;
case "mte": System.out.println(">="); break;
case "lte": System.out.println("<="); break;
case "de": System.out.println("=="); break;
};:};
OPR::= double_equal{:RESULT = "de";:} | less_than {:RESULT = "lt";:} | more_than {:RESULT = "mt";:} | more_than_equal_to  {:RESULT = "mte";:} | less_than_equal_to {:RESULT = "lte";:};

LEXP ::= EXP | LEXP comma {:System.out.println(",");:} EXP;
EXP ::= EXP:exp1 OP:op EXP:exp2 {:System.out.print(exp1);switch(op){
case "sa": System.out.print(" + "); break;
case "ss": System.out.println(" - "); break;
case "ms": System.out.println(" * "); break;
case "s": System.out.println(" / "); break;
case "p": System.out.println(" % "); break;
};System.out.print(exp2);:} | FACTOR ;
OP ::= addition_sign {:RESULT = "as";:} | substraction_sign {:RESULT = "ss";:} | multiplication_sign {:RESULT = "ms";:}| slash {:RESULT = "s";:}| percent{:RESULT = "p";:};
FACTOR ::= ident:ident1 left_parenthesis {:System.out.print(ident1 +" (");:}LEXP right_parenthesis {:System.out.print(")");:} | left_parenthesis {:System.out.print("(");:}EXP right_parenthesis {:System.out.print(")");:}|
	 constint:const1 {:System.out.print(const1);:} | constfloat:const1 {:System.out.print(const1);:} | constlit: const1 {:System.out.print(const1);:} | ID:id {:System.out.print(id);:};
LFIELD ::= LFIELD TYPE:type LID:ident1 semicolon {:switch(type){
case "v": System.out.print("void "); break;
case "i": System.out.print("int "); break;
case "f": System.out.print("float "); break;
};System.out.println(ident1+";");:} | TYPE:type LID:ident1 semicolon {:switch(type){
case "v": System.out.print("void "); break;
case "i": System.out.print("int "); break;
case "f": System.out.print("float "); break;
};System.out.println(ident1+";");:};
ID ::= ident:ident1 {:String s = ident1;RESULT = s;:}  | ident:ident1 dot ident:ident2 {:RESULT=ident1;:};
LID ::= ID:ident1 {:RESULT = ident1;:}  | LID comma ID;
ID ::= ident:ident1 LDIM {:RESULT = ident1;:};
LDIM ::= LDIM left_squarebracket constint right_squarebracket | left_squarebracket constint right_squarebracket;